create table customers (
  customer_id    bigint generated always as identity primary key,
  email          text not null unique,
  phone          text,
  first_name     text,
  last_name      text,
  middle_name    text,
  registred_at   timestamptz not null default now(),
  marketingopt_in boolean not null default false,
  status         smallint not null default 1
  -- status: 1 = активен, 0 = неактивен, 2 = заблокирован
);

create table customer_addresses (
  address_id     bigint generated always as identity primary key,
  customer_id    bigint not null,
  is_default     boolean not null default false,
  receiver_name  text not null,
  country_code   char(2) not null,
  city           text not null,
  addressline    text not null,
  created_at     timestamptz not null default now(),
  constraint fk_customer_addresses_customer
    foreign key (customer_id) references public.customers(customer_id) on delete cascade,
  constraint chk_country_code_iso2_upper check (country_code ~ '^[A-Z]{2}$')
);

-- Индексы и ограничение: по одному дефолтному адресу на клиента
create index if not exists ix_customer_addresses_customer_id on public.customer_addresses(customer_id);

create unique index if not exists uq_customer_default_address
  on public.customer_addresses(customer_id)
  where is_default;


create table if not exists public.categories (
  category_id bigint generated always as identity primary key,
  name        text not null,
  slug        text not null,
  is_active   boolean not null default true,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  constraint chk_categories_slug_format check (slug ~ '^[a-z0-9]+(?:-[a-z0-9]+)*$')
);

-- Уникальные индексы
create unique index if not exists ux_categories_slug on public.categories (slug);
create unique index if not exists ux_categories_name on public.categories (name);


create table if not exists products (
  product_id  bigint generated always as identity primary key,
  name        text not null,
  slug        text not null,
  brand       text not null,
  description text,
  attributes  jsonb not null default '{}'::jsonb,
  is_active   boolean not null default true,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  constraint chk_products_slug_format check (slug ~ '^[a-z0-9]+(?:-[a-z0-9]+)*$'),
  constraint chk_products_name_not_blank check (btrim(name) <> ''),
  constraint chk_products_brand_not_blank check (btrim(brand) <> '')
);


CREATE TABLE IF NOT EXISTS product_categories (
  product_id  BIGINT NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
  category_id BIGINT NOT NULL REFERENCES categories(category_id) ON DELETE CASCADE,
  PRIMARY KEY (product_id, category_id)
);

-- Индекс на category_id (ускорит выборки по категории)
CREATE INDEX IF NOT EXISTS idx_prod;

  CREATE TABLE IF NOT EXISTS product_variants (
  variant_id    BIGSERIAL PRIMARY KEY,
  product_id    BIGINT NOT NULL REFERENCES products(product_id) ON DELETE CASCADE,
  price         NUMERIC,
  cost          NUMERIC,
  weight_grams  INTEGER,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE warehouses (
  warehouse_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  code        TEXT NOT NULL UNIQUE,
  name        TEXT NOT NULL,
  address     JSONB NOT NULL,
  is_active   BOOLEAN NOT NULL DEFAULT TRUE,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  CHECK (btrim(code) <> ''),
  CHECK (btrim(name) <> '')
);

CREATE TABLE inventory (
  warehouse_id BIGINT NOT NULL,
  variant_id   BIGINT NOT NULL,
  qty          INTEGER NOT NULL DEFAULT 0,
  reserved_qty INTEGER NOT NULL DEFAULT 0,
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  CONSTRAINT inventory_pk PRIMARY KEY (warehouse_id, variant_id),
  CONSTRAINT inventory_wh_fk FOREIGN KEY (warehouse_id)
    REFERENCES warehouses(warehouse_id) ON DELETE CASCADE,
  CONSTRAINT inventory_var_fk FOREIGN KEY (variant_id)
    REFERENCES product_variants(variant_id) ON DELETE CASCADE,
  CONSTRAINT qty_nonneg CHECK (qty >= 0),
  CONSTRAINT reserved_nonneg CHECK (reserved_qty >= 0),
  CONSTRAINT reserved_lte_qty CHECK (reserved_qty <= qty)
);
